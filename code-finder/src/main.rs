use anyhow::{Result, Context};
use serde::{Deserialize, Serialize};
use code_finder_macros::{rg, model_shell_script}; // Import both macros
use shebling_macros::{shebling, bash}; // Import both shebling! and bash! macros
use solfun_macros::{figlet, codegen, dwim, llm, mcp, service_finder}; // Import fun, dev-ops, and new integration macros

// Embed the JSON model at compile time
const FIND_CODE_SH_MODEL_JSON: &str = include_str!("../find-code-sh-model.json");

// Use the procedural macro to model the shell script
// This will generate a module, e.g., `find_code_sh`, with `execute_modeled_script` function.
model_shell_script! { FIND_CODE_SH_MODEL_JSON }

// Invoke the shebling! macro on our dummy shell script
// This will output its simulated analysis during compilation.
shebling! { path: "code-finder/dummy_script.sh" }

// Invoke the bash! macro with an inline bash snippet
// This will also output its AST analysis during compilation.
bash! { "echo \"Hello from bash! macro\" | grep \"Hello\"" }

// Add a !figlet "i hope someone is witnessing this! god bless you all. #SOLFUNMEME" for fun.
figlet! { "i hope someone is witnessing this! god bless you all. #SOLFUNMEME" }

// Demonstrate some of the new dev-ops and LLM macros
codegen! { r#"
    /// A generated function.
    pub fn new_generated_function() -> u32 {
        42
    }
"# }

dwim! { "Refactor all redundant code and optimize for performance." }

// The llm! macro now resolves into toolcall! which then resolves into results!
llm! { "model: 'gemini-1.5-pro', temp: '0.8', prompt: 'Summarize the philosophy behind Bash-inside-out in one paragraph.'" }

// Demonstrate Model Context Provider
mcp! { "url: 'https://github.com/meta-introspector/patch-build-rs', type: 'project:Repository', owner: 'MetaIntrospector'" }

// Demonstrate Service Finder
service_finder! { "need: 'create_ticket', macro_call: 'solfun_macros::ticket!(\"New feature\")'" }

fn main() -> Result<()> {
    // Invoke the function generated by the model_shell_script! macro
    find_code_sh::execute_modeled_script();

    println!("\nModeling complete. The above output describes the operations of the original find-code.sh script.");
    println!("In a truly closed-world model, these 'println!' calls would be replaced by operations on a symbolic state.");
    println!("The rg! macro still exists for direct invocation if needed for specific searches.");
    
    // Check compilation output for all macro messages.
    println!("\nAll macros invoked. Check compilation output for their messages and conceptual actions.");

    Ok(())
}

