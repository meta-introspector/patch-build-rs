use std::fs;
use std::collections::HashMap; // Import HashMap

// This line includes the code generated by our build.rs script.
include!(concat!(env!("OUT_DIR"), "/generated_state.rs"));

fn main() {
    println!("--- Emoji State Machine Initialized ---");

    let mut state = GeneratedState {
        energy: 0,
        history: Vec::new(),
        ideas: Vec::new(),
        complexity: 0,
        assets: 0,
        agents: 0,
        resources: HashMap::new(),
        current_goal: None,
        crates: Vec::new(),
        is_locked: false,
        graph_complexity: 0,
        sculpt_value: 0,
        dao_members: 0,
        votes: 0,
        virtue_score: 0,
        beauty_index: 0,
        truth_revealed: false,
        ultimate_answer: None,
        vendored_deps: Vec::new(), // Initialize new field
        github_activity: Vec::new(), // Initialize new field
        fork_count: 0, // Initialize new field
        active_branches: Vec::new(), // Initialize new field
        rebase_events: 0, // Initialize new field
        patches_applied: 0, // Initialize new field
        adaptation_score: 0, // Initialize new field
        abstraction_level: 0, // Initialize new field
        filtered_items: 0, // Initialize new field
        mapped_elements: 0, // Initialize new field
        reduced_value: 0, // Initialize new field
        metis_partitions: 0, // Initialize new field
        harmonic_balance: 0, // Initialize new field
    };
    
    let mut consensus_reached = false;

    println!("\nGenesis State: energy={}, complexity={}, ideas={}, assets={}, agents={}, resources={:?}, goal={:?}, crates={:?}, locked={}, graph_complexity={}, sculpt_value={}, dao_members={}, votes={}, virtue_score={}, beauty_index={}, truth_revealed={}, ultimate_answer={:?}, vendored_deps={:?}, github_activity={:?}, fork_count={}, active_branches={:?}, rebase_events={}, patches_applied={}, adaptation_score={}, abstraction_level={}, filtered_items={}, mapped_elements={}, reduced_value={}, metis_partitions={}, harmonic_balance={}, history_len={}", 
        state.energy, state.complexity, state.ideas.len(), state.assets, state.agents, state.resources, state.current_goal, state.crates, state.is_locked, state.graph_complexity, state.sculpt_value, state.dao_members, state.votes, state.virtue_score, state.beauty_index, state.truth_revealed, state.ultimate_answer, state.vendored_deps, state.github_activity, state.fork_count, state.active_branches, state.rebase_events, state.patches_applied, state.adaptation_score, state.abstraction_level, state.filtered_items, state.mapped_elements, state.reduced_value, state.metis_partitions, state.harmonic_balance, state.history.len());

    let mut tape_paths: Vec<_> = fs::read_dir("./tapes").unwrap()
                                    .map(|r| r.unwrap().path())
                                    .collect();
    tape_paths.sort(); // Process tapes in order
    
    for tape_path in tape_paths {
        let tape_name = tape_path.file_name().unwrap().to_str().unwrap();
        println!("\n--- Processing Tape: {} ---", tape_name);

        let content = fs::read_to_string(&tape_path).unwrap();
        for line in content.lines() {
            if line.contains("ğŸ”„") {
                state.reset_cycle();
            }
            if line.contains("ğŸš€") {
                state.launch();
            }
            if line.contains("ğŸ’¡") {
                let idea = line.split_once("ğŸ’¡:").unwrap_or(("", "Unknown idea")).1;
                state.new_idea(idea);
            }
            if line.contains("ğŸŒ±") {
                state.evolve();
            }
            if line.contains("ğŸ’°") {
                let amount_str = line.split_once("ğŸ’°:").unwrap_or(("", "0")).1;
                if let Ok(amount) = amount_str.parse::<u64>() {
                    state.acquire_assets(amount);
                } else {
                    println!("âš ï¸ Invalid amount for assets: {}", amount_str);
                }
            }
            if line.contains("ğŸ¤–") {
                let count_str = line.split_once("ğŸ¤–:").unwrap_or(("", "0")).1;
                if let Ok(count) = count_str.parse::<u64>() {
                    state.deploy_agent(count);
                } else {
                    println!("âš ï¸ Invalid count for agents: {}", count_str);
                }
            }
            if line.contains("ğŸ’") {
                if let Some((_, resource_info)) = line.split_once("ğŸ’:") {
                    if let Some((name, amount_str)) = resource_info.split_once(":") {
                        if let Ok(amount) = amount_str.parse::<u64>() {
                            state.add_resource(name.to_string(), amount);
                        } else {
                            println!("âš ï¸ Invalid amount for resource '{}': {}", name, amount_str);
                        }
                    } else {
                        println!("âš ï¸ Invalid resource format: {}", resource_info);
                    }
                }
            }
            if line.contains("ğŸ¯") {
                if line.contains("ğŸ¯?:") { // Check for goal reasonableness
                    state.is_goal_reasonable();
                } else { // Set a new goal
                    let goal = line.split_once("ğŸ¯:").unwrap_or(("", "Unknown goal")).1;
                    state.set_goal(goal);
                }
            }
            if line.contains("ğŸ“¦") {
                let crate_name = line.split_once("ğŸ“¦:").unwrap_or(("", "unknown-crate")).1;
                state.add_crate(crate_name);
            }
            if line.contains("ğŸ”’") {
                if line.contains("ğŸ”’:false") {
                    state.unlock_state();
                } else {
                    state.lock_state();
                }
            }
            if line.contains("ğŸ•¸ï¸") {
                state.analyze_graph();
            }
            if line.contains("ğŸ—¿") {
                state.sculpt_state();
            }
            if line.contains("ğŸ›ï¸") {
                let members_str = line.split_once("ğŸ›ï¸:").unwrap_or(("", "0")).1;
                if let Ok(members) = members_str.parse::<u64>() {
                    state.form_dao(members);
                } else {
                    println!("âš ï¸ Invalid member count for DAO: {}", members_str);
                }
            }
            if line.contains("ğŸ—³ï¸") {
                state.cast_vote();
            }
            if line.contains("ğŸ˜‡") {
                let points_str = line.split_once("ğŸ˜‡:").unwrap_or(("", "0")).1;
                if let Ok(points) = points_str.parse::<u64>() {
                    state.cultivate_virtue(points);
                } else {
                    println!("âš ï¸ Invalid virtue points: {}", points_str);
                }
            }
            if line.contains("âœ¨") {
                let points_str = line.split_once("âœ¨:").unwrap_or(("", "0")).1;
                if let Ok(points) = points_str.parse::<u64>() {
                    state.enhance_beauty(points);
                } else {
                    println!("âš ï¸ Invalid beauty points: {}", points_str);
                }
            }
            if line.contains("ğŸ”") {
                state.seek_truth();
            }
            if line.contains("ğŸ”¢") {
                state.find_ultimate_answer();
            }
            if line.contains("ğŸšš") {
                let dep_name = line.split_once("ğŸšš:").unwrap_or(("", "unknown-dep")).1;
                state.vendor_dependency(dep_name);
            }
            if line.contains("ğŸ™") {
                let repo_info = line.split_once("ğŸ™:").unwrap_or(("", "unknown-repo:action")).1;
                if let Some((repo, action)) = repo_info.split_once(":") {
                    if action == "init" {
                        state.fetch_repo_info(repo);
                    } else if action == "pull_request" {
                        state.contribute_to_repo(repo, "Pull Request");
                    } else if action == "issue_fix" {
                        state.contribute_to_repo(repo, "Issue Fix");
                    } else {
                        println!("âš ï¸ Unknown GitHub action: {}", action);
                    }
                } else {
                    state.fetch_repo_info(repo_info);
                }
            }
            if line.contains("ğŸ´") {
                state.create_fork();
            }
            if line.contains("ğŸŒ¿") {
                let branch_name = line.split_once("ğŸŒ¿:").unwrap_or(("", "main")).1;
                state.create_branch(branch_name);
            }
            if line.contains("ğŸ”ƒ") {
                state.perform_rebase();
            }
            if line.contains("ğŸ©¹") {
                state.apply_patch();
            }
            if line.contains("ğŸ§¬") {
                let level_str = line.split_once("ğŸ§¬:").unwrap_or(("", "1")).1;
                if let Ok(level) = level_str.parse::<u64>() {
                    state.adapt_system(level);
                } else {
                    println!("âš ï¸ Invalid adaptation level: {}", level_str);
                }
            }
            if line.contains("â¬†ï¸") {
                state.lift_abstraction();
            }
            if line.contains("ğŸ§¹") {
                let items_str = line.split_once("ğŸ§¹:").unwrap_or(("", "0")).1;
                if let Ok(items) = items_str.parse::<u64>() {
                    state.filter_data(items);
                } else {
                    println!("âš ï¸ Invalid filter items count: {}", items_str);
                }
            }
            if line.contains("ğŸ—ºï¸") {
                let elements_str = line.split_once("ğŸ—ºï¸:").unwrap_or(("", "0")).1;
                if let Ok(elements) = elements_str.parse::<u64>() {
                    state.map_transformation(elements);
                } else {
                    println!("âš ï¸ Invalid mapped elements count: {}", elements_str);
                }
            }
            if line.contains("ğŸ“‰") {
                let items_str = line.split_once("ğŸ“‰:").unwrap_or(("", "0")).1;
                if let Ok(items) = items_str.parse::<u64>() {
                    state.reduce_data(items);
                } else {
                    println!("âš ï¸ Invalid reduced items count: {}", items_str);
                }
            }
            if line.contains("ğŸ¦‰") {
                let partitions_str = line.split_once("ğŸ¦‰:").unwrap_or(("", "1")).1;
                if let Ok(partitions) = partitions_str.parse::<u64>() {
                    state.partition_graph(partitions);
                } else {
                    println!("âš ï¸ Invalid partition count: {}", partitions_str);
                }
            }
            if line.contains("ğŸ¶") {
                let points_str = line.split_once("ğŸ¶:").unwrap_or(("", "0")).1;
                if let Ok(points) = points_str.parse::<u64>() {
                    state.achieve_harmony(points);
                } else {
                    println!("âš ï¸ Invalid harmony points: {}", points_str);
                }
            }
            if line.contains("ğŸ“œ") { // Generic record event after specific actions
                let event = line.split_once("ğŸ“œ:").unwrap_or(("", "Unknown event")).1;
                state.record(event);
            }
            if line.contains("ğŸ’”") {
                let reason = line.split_once("ğŸ’”:").unwrap_or(("", "Unknown reason")).1;
                state.record(&format!("Negative feedback: {}", reason));
                state.decay();
            }
            if line.contains("ğŸ¤–ğŸŒğŸ“ŠğŸ”—") {
                println!("ğŸ¤ Paxos Consensus Sequence Detected!");
                consensus_reached = true;
            }
        }

        if consensus_reached {
            println!("âœ¨ Consensus Reached! Applying major state evolution.");
            state.energy += 1000;
            state.evolve();
            state.record("Paxos consensus achieved: Major protocol upgrade.");
            consensus_reached = false; // Reset for the next consensus cycle
        }

        println!("State after tape {}: energy={}, complexity={}, ideas={}, assets={}, agents={}, resources={:?}, goal={:?}, crates={:?}, locked={}, graph_complexity={}, sculpt_value={}, dao_members={}, votes={}, virtue_score={}, beauty_index={}, truth_revealed={}, ultimate_answer={:?}, vendored_deps={:?}, github_activity={:?}, fork_count={}, active_branches={:?}, rebase_events={}, patches_applied={}, adaptation_score={}, abstraction_level={}, filtered_items={}, mapped_elements={}, reduced_value={}, metis_partitions={}, harmonic_balance={}, history_len={}", 
            tape_name, state.energy, state.complexity, state.ideas.len(), state.assets, state.agents, state.resources, state.current_goal, state.crates, state.is_locked, state.graph_complexity, state.sculpt_value, state.dao_members, state.votes, state.virtue_score, state.beauty_index, state.truth_revealed, state.ultimate_answer, state.vendored_deps, state.github_activity, state.fork_count, state.active_branches, state.rebase_events, state.patches_applied, state.adaptation_score, state.abstraction_level, state.filtered_items, state.mapped_elements, state.reduced_value, state.metis_partitions, state.harmonic_balance, state.history.len());
    }

    println!("\n--- Final Converged State ---");
    println!("Final Energy: {}", state.energy);
    println!("Final Complexity: {}", state.complexity);
    println!("Emergent Ideas: {:?}", state.ideas);
    println!("Final Assets: {}", state.assets);
    println!("Final Agents: {}", state.agents);
    println!("Final Resources: {:?}", state.resources);
    println!("Final Crates: {:?}", state.crates);
    println!("Final Lock State: {}", state.is_locked);
    println!("Final Graph Complexity: {}", state.graph_complexity);
    println!("Final Sculpt Value: {}", state.sculpt_value);
    println!("Final DAO Members: {}", state.dao_members);
    println!("Final Votes: {}", state.votes);
    println!("Final Virtue Score: {}", state.virtue_score);
    println!("Final Beauty Index: {}", state.beauty_index);
    println!("Truth Revealed: {}", state.truth_revealed);
    println!("Ultimate Answer: {:?}", state.ultimate_answer);
    println!("Final Vendored Dependencies: {:?}", state.vendored_deps);
    println!("Final GitHub Activity: {:?}", state.github_activity);
    println!("Final Fork Count: {}", state.fork_count);
    println!("Final Active Branches: {:?}", state.active_branches);
    println!("Final Rebase Events: {}", state.rebase_events);
    println!("Final Patches Applied: {}", state.patches_applied);
    println!("Final Adaptation Score: {}", state.adaptation_score);
    println!("Final Abstraction Level: {}", state.abstraction_level);
    println!("Final Filtered Items: {}", state.filtered_items);
    println!("Final Mapped Elements: {}", state.mapped_elements);
    println!("Final Reduced Value: {}", state.reduced_value);
    println!("Final Metis Partitions: {}", state.metis_partitions);
    println!("Final Harmonic Balance: {}", state.harmonic_balance);
    println!("Final Goal: {:?}", state.current_goal);
    println!("Immutable History: {:?}", state.history);
}
